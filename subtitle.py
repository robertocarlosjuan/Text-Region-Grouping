import os
import re
import cv2
from tqdm import tqdm
from glob import glob

import speech_recognition as sr
from paddleocr import PaddleOCR

def atoi(text):
    return int(text) if text.isdigit() else text

def natural_keys(text):
    '''
    alist.sort(key=natural_keys) sorts in human order
    http://nedbatchelder.com/blog/200712/human_sorting.html
    (See Toothy's implementation in the comments)
    '''
    return [ atoi(c) for c in re.split(r'(\d+)', text) ]

def check_coor_match(prev_coor, curr_coor, margin):
    mismatch = False
    for p, c in zip(prev_coor, curr_coor):
        if abs(p-c) <= margin:
            continue
        else:
            mismatch = True
            break

    return mismatch

lang = 'ch'
input_path = '../montage_detection/sinovac_ver/query_video' 
frame_save_path = 'frames'
temp_path = 'temp'
os.makedirs(frame_save_path, exist_ok=True)
os.makedirs(temp_path, exist_ok=True)

base_filename = 'ChineseSinovacVideo'
cap = cv2.VideoCapture('{}/{}.mp4'.format(input_path, base_filename))
fps = round(cap.get(cv2.CAP_PROP_FPS)) 
width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))  #width of image
height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
out_file = '{}/{}.mp4'.format(temp_path, base_filename)
fourcc = cv2.VideoWriter_fourcc(*'mp4v')
out = cv2.VideoWriter(out_file, fourcc, fps, (width, height))
# success,image = cap.read()
# count = 0
# while success:
#   cv2.imwrite("{}/{}_{}.jpg".format(frame_save_path, base_filename, count), image)     # save frame as JPEG file      
#   success, image = cap.read()
#   print('Read a new frame: ', success)
#   count += 1

ocr = PaddleOCR(use_angle_cls=True, lang=lang)
bbox_dict = {}
bbox_hist = []
subtitle_bboxes = []
frames = glob('{}/{}_*.jpg'.format(frame_save_path, base_filename))
frames.sort(key=natural_keys)
for idx, frame in tqdm(enumerate(frames)):
    ocr_bboxes = ocr.ocr(frame, cls=True)

    coors_to_delete = []
    for tracked_coor, frame_range in bbox_dict.items():
        continued = False
        for curr_bbox in ocr_bboxes:
            curr_coor = tuple([curr_bbox[0][0][0], curr_bbox[0][0][1], curr_bbox[0][2][0], curr_bbox[0][2][1]])
            if not check_coor_match(tracked_coor, curr_coor, 5) and idx == frame_range[-1] + 1:
                bbox_dict[tracked_coor][-1] = idx
                continued = True
                break
        if not continued:
            coors_to_delete.append(tracked_coor)
            if frame_range[-1] - frame_range[0] > 0:
                bbox_hist.append([tracked_coor, frame_range])
    
    for curr_bbox in ocr_bboxes:
        curr_coor = tuple([curr_bbox[0][0][0], curr_bbox[0][0][1], curr_bbox[0][2][0], curr_bbox[0][2][1]])
        already_tracked = False
        for tracked_coor, frame_range in bbox_dict.items():
            if not check_coor_match(tracked_coor, curr_coor, 5):
                already_tracked = True
                break
        if not already_tracked:
            bbox_dict[curr_coor] = [idx, idx]

    for coor in coors_to_delete:
        del bbox_dict[coor]

    # print('TRACKING:', bbox_dict)
    # print('HISTORY:', bbox_hist)

# bbox_hist = [[(313.0,712.0,650.0,693.0),[0,2]],[(315.0,737.0,651.0,731.0),[0,4]],[(25.0,24.0,163.0,75.0),[2,5]],[(307.0,645.0,642.0,636.0),[0,8]],[(299.0,787.0,456.0,813.0),[7,8]],[(349.0,704.0,652.0,692.0),[3,10]],[(308.0,642.0,648.0,632.0),[9,10]],[(73.0,29.0,164.0,73.0),[8,11]],[(299.0,787.0,458.0,813.0),[10,11]],[(25.0,24.0,163.0,75.0),[12,15]],[(308.0,648.0,647.0,629.0),[11,17]],[(358.0,702.0,656.0,689.0),[11,18]],[(299.0,787.0,452.0,813.0),[12,19]],[(73.0,29.0,164.0,73.0),[18,19]],[(306.0,640.0,651.0,627.0),[18,19]],[(299.0,787.0,458.0,813.0),[20,21]],[(353.0,700.0,662.0,687.0),[19,23]],[(306.0,640.0,656.0,626.0),[21,23]],[(299.0,787.0,452.0,813.0),[22,24]],[(25.0,24.0,163.0,75.0),[22,25]],[(348.0,702.0,669.0,683.0),[24,28]],[(306.0,636.0,662.0,625.0),[24,29]],[(299.0,787.0,458.0,813.0),[25,29]],[(73.0,29.0,164.0,73.0),[28,31]],[(342.0,702.0,673.0,682.0),[29,31]],[(332.0,705.0,677.0,681.0),[32,33]],[(25.0,23.0,163.0,77.0),[32,35]],[(299.0,787.0,452.0,813.0),[30,37]],[(326.0,705.0,677.0,679.0),[34,39]],[(73.0,29.0,164.0,73.0),[38,39]],[(305.0,639.0,667.0,619.0),[30,40]],[(308.0,636.0,670.0,613.0),[41,43]],[(25.0,24.0,163.0,75.0),[42,43]],[(130.0,789.0,588.0,812.0),[42,45]],[(73.0,29.0,164.0,73.0),[48,49]],[(25.0,28.0,160.0,75.0),[53,55]],[(73.0,29.0,164.0,73.0),[58,59]],[(25.0,23.0,163.0,77.0),[62,65]],[(30.0,462.0,177.0,503.0),[0,69]],[(73.0,29.0,164.0,73.0),[68,69]],[(182.0,648.0,285.0,668.0),[70,72]],[(343.0,665.0,667.0,681.0),[70,72]],[(495.0,825.0,602.0,843.0),[71,72]],[(177.0,505.0,504.0,524.0),[70,73]],[(339.0,815.0,428.0,829.0),[70,73]],[(30.0,465.0,189.0,500.0),[71,74]],[(25.0,28.0,160.0,75.0),[73,75]],[(490.0,821.0,713.0,843.0),[73,75]],[(336.0,663.0,667.0,681.0),[73,76]],[(28.0,465.0,180.0,502.0),[75,76]],[(171.0,504.0,502.0,524.0),[74,77]],[(179.0,647.0,279.0,669.0),[74,77]],[(330.0,815.0,422.0,828.0),[74,78]],[(334.0,592.0,385.0,605.0),[76,78]],[(27.0,466.0,173.0,496.0),[77,78]],[(26.0,493.0,97.0,507.0),[77,79]],[(331.0,663.0,661.0,681.0),[77,79]],[(73.0,29.0,164.0,73.0),[78,79]],[(483.0,821.0,716.0,841.0),[76,80]],[(27.0,465.0,162.0,498.0),[79,80]],[(553.0,600.0,584.0,609.0),[79,80]],[(585.0,759.0,615.0,768.0),[80,81]],[(165.0,505.0,496.0,524.0),[78,82]],[(324.0,813.0,420.0,828.0),[79,82]],[(173.0,647.0,273.0,669.0),[79,83]],[(545.0,600.0,582.0,609.0),[81,83]],[(578.0,757.0,617.0,771.0),[82,83]],[(325.0,590.0,384.0,605.0),[80,84]],[(327.0,663.0,654.0,680.0),[80,84]],[(475.0,821.0,716.0,841.0),[81,84]],[(26.0,465.0,158.0,499.0),[83,84]],[(317.0,815.0,416.0,825.0),[83,84]],[(25.0,24.0,163.0,75.0),[82,85]],[(160.0,504.0,490.0,524.0),[83,86]],[(165.0,647.0,267.0,669.0),[84,87]],[(319.0,812.0,410.0,825.0),[85,87]],[(24.0,465.0,156.0,503.0),[86,87]],[(16.0,492.0,74.0,507.0),[86,87]],[(320.0,588.0,379.0,607.0),[86,87]],[(574.0,756.0,611.0,769.0),[86,87]],[(414.0,600.0,453.0,613.0),[84,88]],[(320.0,660.0,647.0,681.0),[85,89]],[(73.0,29.0,164.0,73.0),[88,89]],[(11.0,491.0,87.0,509.0),[88,89]],[(320.0,592.0,372.0,605.0),[88,90]],[(574.0,757.0,605.0,767.0),[89,90]],[(9.0,491.0,93.0,509.0),[90,91]],[(468.0,820.0,716.0,841.0),[85,92]],[(156.0,504.0,484.0,524.0),[87,92]],[(316.0,813.0,405.0,827.0),[89,92]],[(314.0,588.0,375.0,607.0),[91,92]],[(408.0,600.0,449.0,613.0),[91,93]],[(160.0,646.0,261.0,666.0),[89,94]],[(22.0,464.0,143.0,498.0),[88,95]],[(315.0,661.0,641.0,680.0),[90,95]],[(25.0,24.0,163.0,75.0),[92,95]],[(314.0,591.0,368.0,605.0),[93,95]],[(566.0,756.0,606.0,765.0),[95,96]],[(151.0,504.0,478.0,524.0),[93,97]],[(652.0,681.0,704.0,695.0),[95,98]],[(462.0,819.0,716.0,840.0),[93,99]],[(25.0,465.0,137.0,498.0),[96,99]],[(73.0,29.0,164.0,73.0),[98,99]],[(9.0,489.0,81.0,508.0),[94,100]],[(158.0,647.0,254.0,665.0),[95,100]],[(310.0,660.0,635.0,680.0),[96,101]],[(11.0,489.0,71.0,508.0),[101,102]],[(136.0,732.0,430.0,756.0),[43,103]],[(642.0,755.0,708.0,764.0),[100,103]],[(25.0,24.0,163.0,75.0),[102,103]],[(144.0,504.0,473.0,524.0),[98,104]],[(25.0,465.0,144.0,498.0),[100,105]],[(397.0,600.0,431.0,609.0),[104,105]],[(643.0,681.0,703.0,695.0),[104,105]],[(455.0,819.0,716.0,839.0),[100,106]],[(152.0,647.0,250.0,665.0),[101,106]],[(73.0,29.0,164.0,73.0),[108,109]],[(145.0,646.0,248.0,665.0),[107,110]],[(642.0,680.0,701.0,693.0),[107,110]],[(394.0,600.0,437.0,609.0),[109,110]],[(437.0,600.0,472.0,609.0),[109,110]],[(557.0,755.0,631.0,764.0),[109,110]],[(304.0,661.0,630.0,677.0),[102,111]],[(146.0,645.0,242.0,664.0),[111,112]],[(643.0,681.0,674.0,691.0),[111,112]],[(393.0,600.0,431.0,609.0),[111,113]],[(555.0,755.0,594.0,764.0),[111,113]],[(25.0,24.0,163.0,75.0),[112,115]],[(140.0,503.0,467.0,524.0),[105,118]],[(0.0,474.0,149.0,494.0),[110,118]],[(390.0,597.0,555.0,609.0),[114,118]],[(73.0,29.0,164.0,73.0),[118,119]],[(130.0,787.0,588.0,813.0),[51,121]],[(449.0,819.0,716.0,837.0),[107,121]],[(300.0,660.0,622.0,677.0),[112,121]],[(144.0,643.0,244.0,665.0),[114,121]],[(134.0,500.0,462.0,520.0),[119,121]],[(3.0,472.0,144.0,495.0),[120,121]],[(386.0,595.0,549.0,608.0),[120,121]],[(637.0,677.0,701.0,691.0),[120,121]],[(18.0,88.0,272.0,122.0),[0,124]],[(25.0,24.0,163.0,75.0),[122,124]],[(608.0,1171.0,698.0,1216.0),[126,127]],[(570.0,1169.0,699.0,1219.0),[128,130]],[(600.0,1172.0,700.0,1217.0),[143,144]],[(28.0,462.0,177.0,503.0),[122,147]],[(570.0,1169.0,699.0,1219.0),[148,149]],[(136.0,732.0,424.0,755.0),[104,151]],[(567.0,1165.0,700.0,1221.0),[153,154]],[(32.0,467.0,184.0,500.0),[149,158]],[(570.0,1169.0,699.0,1219.0),[158,159]],[(30.0,461.0,179.0,503.0),[159,162]],[(251.0,791.0,467.0,813.0),[124,164]],[(29.0,454.0,216.0,516.0),[163,165]],[(570.0,1169.0,699.0,1219.0),[168,169]],[(30.0,462.0,185.0,504.0),[167,182]],[(30.0,462.0,179.0,503.0),[183,190]],[(224.0,784.0,495.0,812.0),[169,196]],[(599.0,1166.0,699.0,1221.0),[203,204]],[(226.0,791.0,495.0,813.0),[197,218]],[(31.0,462.0,173.0,503.0),[191,219]],[(573.0,1169.0,699.0,1219.0),[218,219]],[(28.0,464.0,175.0,497.0),[220,223]],[(602.0,1172.0,700.0,1217.0),[223,224]],[(573.0,1169.0,699.0,1219.0),[228,229]],[(600.0,1172.0,700.0,1217.0),[233,234]],[(27.0,461.0,175.0,503.0),[224,235]],[(21.0,458.0,175.0,504.0),[236,237]],[(570.0,1169.0,699.0,1219.0),[238,239]],[(570.0,1169.0,699.0,1219.0),[248,249]],[(600.0,1172.0,700.0,1217.0),[253,254]],[(599.0,1166.0,699.0,1221.0),[263,264]],[(192.0,791.0,529.0,813.0),[221,282]],[(599.0,1166.0,699.0,1221.0),[283,284]],[(573.0,1169.0,699.0,1219.0),[288,289]],[(566.0,1171.0,700.0,1219.0),[299,300]],[(602.0,1172.0,700.0,1217.0),[303,304]],[(606.0,1169.0,699.0,1219.0),[306,307]],[(570.0,1169.0,699.0,1219.0),[308,309]],[(602.0,1166.0,699.0,1221.0),[313,314]],[(599.0,1166.0,699.0,1221.0),[323,324]],[(570.0,1169.0,699.0,1219.0),[328,329]],[(582.0,1173.0,606.0,1212.0),[333,334]],[(600.0,1172.0,700.0,1217.0),[333,334]],[(218.0,788.0,504.0,815.0),[286,336]],[(570.0,1169.0,699.0,1219.0),[338,339]],[(599.0,1166.0,699.0,1221.0),[343,344]],[(570.0,1169.0,699.0,1219.0),[358,359]],[(600.0,1172.0,700.0,1217.0),[363,364]],[(573.0,1169.0,699.0,1219.0),[368,369]],[(599.0,1166.0,699.0,1221.0),[373,374]],[(578.0,1176.0,615.0,1211.0),[373,374]],[(239.0,788.0,480.0,815.0),[341,391]],[(570.0,1169.0,699.0,1219.0),[398,399]],[(564.0,1168.0,700.0,1220.0),[408,410]],[(599.0,1166.0,699.0,1221.0),[433,434]],[(564.0,1168.0,700.0,1220.0),[438,440]],[(600.0,1172.0,700.0,1217.0),[443,444]],[(205.0,789.0,515.0,812.0),[394,445]],[(573.0,1169.0,699.0,1219.0),[448,449]],[(600.0,1172.0,700.0,1217.0),[453,454]],[(26.0,460.0,175.0,503.0),[239,457]],[(570.0,1169.0,699.0,1219.0),[458,461]],[(600.0,1172.0,700.0,1217.0),[463,464]],[(570.0,1169.0,699.0,1219.0),[468,469]],[(580.0,1177.0,613.0,1209.0),[473,474]],[(600.0,1172.0,700.0,1217.0),[473,474]],[(566.0,1171.0,700.0,1219.0),[479,480]],[(602.0,1172.0,700.0,1217.0),[483,484]],[(573.0,1169.0,699.0,1219.0),[488,489]],[(580.0,1177.0,609.0,1208.0),[493,494]],[(600.0,1172.0,700.0,1217.0),[493,494]],[(251.0,787.0,467.0,813.0),[447,497]]]

frame_to_subtitle = {k:[] for k in range(len(frames))}

for bbox in bbox_hist:
    frame_range = bbox[-1]
    if frame_range[-1] - frame_range[0] >= 10 and bbox[0][-1] >= int(height/2):
        for i in range(frame_range[0], frame_range[-1] + 1):
            frame_to_subtitle[i].append(bbox[0])

for idx, frame in enumerate(frames):
    img = cv2.imread(frame)
    for bbox in frame_to_subtitle[idx]:
        start_point = (int(bbox[0]), int(bbox[1]))
        end_point = (int(bbox[2]), int(bbox[-1]))
        colour = (0, 255, 0)
        cv2.rectangle(img, start_point, end_point, colour)
    out.write(img)

out.release()
cap.release()

print(bbox_hist)

# for bbox in subtitle_bboxes:
#     frame_range = bbox[-1]
#     for frame_num in frame_range:
#         img = cv2.imread('{}/{}_{}.jpg'.format(frame_save_path, base_filename, frame_num))
#         cv2.rectangle(img, (bbox[0][0], bbox[0][1]), (bbox[0][2], bbox[0][-1]), (0, 255, 0))

    # r = sr.Recognizer()
    # temp = sr.AudioFile('{}/temp.wav'.format(asr_temp_path))
    # with temp as source:
    #     temp_audio = r.record(source)

    # if lang == 'eng':
    #     try:
    #         pred_text = r.recognize_google(temp_audio)#, language='en-SG')
    #     except sr.UnknownValueError:
    #         pred_text = 'UNKNOWN'
    # elif lang == 'ch':
    #     try:
    #         pred_text = r.recognize_google(temp_audio, language='zh')
    #     except sr.UnknownValueError:
    #         pred_text = 'UNKNOWN'
   

